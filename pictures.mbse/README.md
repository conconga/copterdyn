# copterdyn

**copterdyn** is a sophisticated simulator for a quadcopter modeled using
multibody simulation concepts.

# history

The quadcopter simulator is outdated, and with its first version completed in 2017.
It was developed using Python 2.7, without any compatibility to any Python
3.0. This was critical in particular with debugging information and frame
generation (animations). Additionally, the first implementation had other issues.
For instance, while the simulation of the dynamics impressive, the project lacked a proper propeller model, and a
piloting (controlling) algorithm. Moreover, the interfaces to any guidance inadequate.

# refactoring

As my career banked to systems engineering, I made a decision to reshape the
project with some reasonable increments with the intention of bringing it
reviving the project also for python 3, populating the simulation with the
complete GNC (guidance-navigation-control) and sensing, and enhancing the
clarity at any interface level.

# System Of Interest

The next paragraphs and respective diagrams will provide the details about the
new project, and what is expected to have achieved. The System of Interest is
modelled using the Model Based System Engineering (MBSE) paradigm.

## use case diagram

The System-of-Interest will provide at least three services:

* to simulate any hover maneuver of the quadcopter (configured by the user);
* to simulate sensors as described by a comercial datasheet; GPS data is an input for the navigation, and will be generated by the sensor simulator;
* to calculate any navigation data, position, velocity and acceleration.


![Package_02_UseCases_UseCases.JPG](Package_02_UseCases_UseCases.JPG?raw=true "Use-Case diagram, and details on stakeholders (I myself!) needs.")

## context diagram

The Context-Diagram for the System-of-Interest (SoI) does not depict any
surprises. The SoI interacts with the User at lauching of any simulation, and
provides data to a logger, file, or disply unit.

![Package_01_SystemContext_SoI_Context.JPG](Package_01_SystemContext_SoI_Context.JPG?raw=true "Context Diagram.")

## Activity: Simulate Hover

The UseCase "Simulate Hover" is decomposed into its subfunctions. Here the role
of Guidance and Piloting are represented by the functions "calculate
trajectory" and "calculate control commands". Most of the functions are allowed
to perform in parallel.

This Activity satisfies some requirements:

* to simulate the full kinematics of a quadcopter, also non-simmetrical quadcopter;
* to enable the development of control laws for the plant;
* to enable the development of guidance laws based on configured missions (waypoints, abrupt structural changes (fail))

![Activity_simulate_hover_simulate_hover.JPG](Activity_simulate_hover_simulate_hover.JPG?raw=true "UseCase: simulate hover")

## Activity: Perform Navigation

The UseCase "Perform Navigation" is decomposed into its subfunctions. The main role of the Activity is to allow the development
of navigation algorithms fusing any source available. For instance, some possible sources supporting the navigation algorithms are:

* gyrometer measurements;
* accelerometer measurements;
* GPS or similar data;
* altitude.

The modularity enables the evaluation of different concepts, like
gyroless-navigation, or navigation supported by static reference points
measured by radars or cameras, for instance.

![Activity_perform_navigation_perform_navigation.JPG](Activity_perform_navigation_perform_navigation.JPG?raw=true "UseCase: perform navigation")

## Activity: Simulate Sensors

The UseCase "Simulate Sensors" is decomposed into its subfunctions. The main
goal of this activity is to convert the state vector describing the dynamic
system into sensor measurements, if any sensors are installed on the system.
For example, a classical sensor set (CSS) for navigation consists of 3 gyros, 3
accelerometers, and GPS. Several assumptions have to be make, for instance:

* the CSS is not installed exactly at the center of gravity of the quadcopter;
* the GPS data is delayed with regard to the actual dynamics;
* the sensors are not ideal, and provide noise measurements.

Due to the modularity of this model, the sensor simulation might be replaced
(or simply configured) to include magnetic sensors, radars, cameras, and
whatever is necessary for your (my) application.

The output of this activity is designed to be the input of the navigation.

![Activity_simulate_sensors_simulate_sensors.JPG](Activity_simulate_sensors_simulate_sensors.JPG?raw=true "UseCase: simulate navigation")

## Functional Allocation

The SysML allows the allocation of \<\<Activity>> as any \<\<Block>>, by any
<<Block>> and <<Activity>>. This enables the modeling of reuse, as a single
<<Activity>> might be a <<Part Property>> of multiple elements of the model.

The next diagram depicts the functional allocation of the UseCases to the
System of Interest. In addition, it shows the allocation of a new <<Activity>>:
"manage time". This activity is intended to manage the pace of the simulation,
continuous and discrete, and handle time events, for instance a change of
configuration programed to happen at a particular timeslot.

![Functional Allocation](Package_03_FunctionalAllocation_functional_allocation.JPG?raw=true "System of Interest: Functional Allocation")

# Path and Trajectory

Along my career I have had several discussions where these terms appear
sometimes interchangeably and not rarely with particular meanings. Whenever one
asks for clarification about any of the terms, a new discussion starts and the
original focus gets lost.

I will describe in the next lines the denotation I first learnt in discussions
with seniors and experts, and articles, which is the one I used in all my
reports about guidance of inteligent weapons (hereafter "robots").

When planning the movement of a robot, the designer will select an intermediate
sequence of positions considering several levels of optimizations. For
instance, the designer might weight differently these cost measures, among
others:

- traveled distance 
- time-to-arrival
- applicable constraints

The selected sequence of positions is the **path** to have followed by the robot.

An aircraft leaving SÃ£o Paulo targeting London cannot flight straight due to
the earth curvature, but along arcs over the earth surface. There is an
uncountable number of possible arcs to serve as the flight **path**, and only one
which is the shortest, and maybe another one which uses the minimum ammount of
querosene seizing atmospheric winds.

A vehicle leaving a mall and targeting home, 10 blocks north plus 10 blocks
east, cannot move freely along the diagonal of the quadrilateral. It must
instead follow specific traffic rules. In virtue of the mentioned rules, some
**paths** will be longer than others, some faster, some nicer, some cheaper.

Another nice example: recent hypersonic weapons "fly" at the borders of earth
atmosphere. The **path** calculation considers limited payload, low drag, and
fast reach.
